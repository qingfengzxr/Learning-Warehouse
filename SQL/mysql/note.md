[TOC]

### 声明

以下所有相关命令行内容均基于ubuntu18.04。具体学习过程源自书籍《MySQL必知必会》。



### MySQL的登录

```
mysql -h 127.0.0.1 -u root -p 
```

参数说明：

- **-h** : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;
- **-u** : 登录的用户名;
- **-p** : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。



### 建立一个新的数据库

```mysql
CREATE DATABASE learning;
```

这样就创建了一个名为 _learning_ 的数据库（数据源）

### 使用一个指定的数据库

```mysql
USE learning;
```

### 执行SQL脚本文件

```mysql
source XX.sql
```

注意：XX.sql 需要路径支持

### 显示内容

```mysql
SHOW DATABASES; //显示存在的数据库
SHOW TABLES;	//显示当前数据库存在的表
SHOW COLUMNS FROM TABLES;	//显示表列
```



### 检索数据

1. **数据的格式化是一个表示问题，而不是一个检索问题**



* 检索单个列

```mysql
SELECT 待检索列名 FROM 预检索表名;
```

* 检索多个列

```mysql
SELECT 待检索列名1,待检索列名2,待检索列名3,...,最后一个待检索列名 FROM 预检索表名;
```

* 检索所有列

```mysql
SELECT * FROM 预检索表名;		
```

* 检索时只返回不同的值

```mysql
SELECT DISTINCT 待检索列名 FROM 预检索表名;
```

注： DISTINCT 关键字应用于所有列而不是它的前置列。意味着当检索了多个列时，只有每个列的所有行都不同，才被检索出来。

* 限制检索结果数量

```mysql
SELECT 待检索列名 FROM 预检索表名 LIMIT 检索开始位置，要检索的行数;
```

注： 检索开始位置可省略，默认为0；如：

```Mysql
SELECT prod_name FROM products LIMIT 5;
```

返回不多于5行，从第  行0  开始（位置参数为0）。



### 排序检索数据

1. **关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义**

* **子句**

SQL语句由子句组成，有些是必需的，有些是可选的。一个子句通常由一个关键字和所提供的数据组成。当前最明显的例子便是 `SELECT `语句的 ```FROM``` 子句。

* 字句的顺序

在给出 `ORDER BY` 字句时，应该保证它位于 `FROM` 字句之后。如果使用 `LIMIT` ,它必须位于 `ORDER BY` 之后。使用子句的次序不对将产生错误消息。

* 单列排序

```mysql
SELECT 待检索列名 FROM 预检索表名 ORDER BY 带检索列名;
```

注： 可以通过非选择检索列进行排序。

* 多列排序

```mysql
SELECT 待检索列名1,待检索列名2,待检索列名3 FROM 预检索表名 ORDER BY 待检索列名2,待检索列名3;
```

在上述排序中，将优先按照  _待检索列名2_  进行排序，仅在多个行具有相同的  _待检索列名2_  时才按 _待检索列名3_

进行再排序。

* 指定排序顺序

```mysql
SELECT 待检索列名1,待检索列名2,待检索列名3 FROM 预检索表名 ORDER BY 待检索列名1 DESC,待检索列名2;
```

数据排序默认以升序排序进行。当要进行 **降序排序** 时，必须指定 ```DESC``` 关键字。 **升序排序** 的关键字为 ```ASC```。

注意： 与 ```DISTINCT``` 关键字不同，```DESC``` 关键字只应用到直接位于其前面的列名。在上述排序命令中，降序只对待检索列名1进行指定，而待检索列名2仍然以默认的升序进行排序。



### 过滤数据

只检索所需数据需要指定 _搜索条件(search criteria)_ ，搜索条件也成为 _过滤条件_。

1. **MySQL在执行匹配时默认不区分大小写**

* 子句顺序

`WHERE`子句在表名`FROM`子句之后给出。

在同时使用了 `ORDER BY` 子句和 `WHERE` 子句时，应该让 `ORDER BY` 位于 `WHERE` 之后，否则会产生错误。

* WHERE子句条件操作符

[][]

| 操作符  | 说明             |
| ------- | ---------------- |
| =       | 等于             |
| <>      | 不等于           |
| !=      | 不等于           |
| <       | 小于             |
| <=      | 小于等于         |
| >       | 大于             |
| >=      | 大于等于         |
| BETWEEN | 在指定两个值之间 |

* 检查单个值

```mysql
SELECT 待检索列名1，待检索列名2 FROM 预检索表名 WHERE 待匹配列名 操作符 范围值;
```

注：待匹配列名 可以是 选择检索列也可以是非选择检索列。

比较字符串时需要用单引号来进行限定。数值比较则不需要引号。如：

```mysql
SELECT prod_name,prod_price FROM products WHERE prod_name = 'fuses';
SELECT vend_id,prod_name FROM products WHERE vend_id <> 1003;
```

* 检测范围值

```mysql
SELECT 待检索列名1，待检索列名2 FROM 预检索表名 WHERE 待匹配列名 BETWEEN 开始值 AND 结束值;
```

注： `BETWEEN` 匹配范围中所有的值，包括指定的开始值和结束值。

* 空值检查

在创建表时，可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值 **NULL**。

**NULL** 无值，它与字段包含0、空字符串或仅仅包含空格不同。

```MYSQL
SELECT 待检索列名1 FROM 预检索表名 WHERE 待匹配列名 IS NULL;	 
```

NULL与不匹配：

在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。

因为未知具有特殊含义，数据库不知道他们是否匹配，所以在匹配过滤或者不匹配过滤时不返回它们。

因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。

* 组合条件检查

1. **MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反**

| 逻辑操作符 | 含义         |
| ---------- | ------------ |
| AND        | 与           |
| OR         | 或           |
| NOT        | 非           |
| IN         | 指定条件范围 |

计算次序：SQL像大多数语言一样，优先处理`AND`操作符。因此要使用圆括号明确地分组相应的操作符。示例：

```mysql
SELECT prod_name,prod_price FROM products 
WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price >= 10;

SELECT prod_name,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name;

SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN (1002,1003);
```

* 通配符过滤

**通配符**: 用来匹配值的一部分的特殊字符。

**搜索模式**:由字面值、通配符或者两者组合而成的搜索条件。

为在搜索子句中使用通配符，必须使用`LIKE`操作符。`LIKE`指示MySQL，后跟的搜索模式利用通配符匹配而不是直接使用相等匹配进行比较。

**使用通配符的技巧**:

1. 不要过度使用通配符。在能达到目的的情况下优先使用其他操作符。
2. 除非绝对必要，不要把通配符放在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来最慢。

| 通配符 | 作用                            |
| ------ | ------------------------------- |
| %      | 任何字符出现任意次数            |
| _      | 和%作用一样，但是只匹配单个字符 |

注： 通配符不可以匹配 NULL。

```MYSQL
SELECT 待检索列名1，待检索列名2 FROM 预检索表名 WHERE 待匹配列名 LIKE '%sample';
```



### 正则表达式搜索

MySQL使用`WHERE`对正则表达式提供了初步的支持，允许你指定正则表达式，过滤`SELECT`检索出来的数据。

1. **MySQL仅支持多数正则表达式实现的一个很小的子集**。

2. **`LIKE`与`REGEXP`之间存在着一个终于差别，`LIKE`匹配整个列，而`REGEXP`在列值中进行匹配**。

3. **MySQL中的正则表达式匹配不区分大小写。为区分大小写需要使用`BINARY`关键字。如：

    `WHERE prod_name REGEXP BINARY 'JetPack .000'`

* 基本字符匹配

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '.000' ORDER BY prod_name;
```

示例输出:

```shell
+--------------+
| prod_name    |
+--------------+
| JetPack 1000 |
| JetPack 2000 |
+--------------+
```

* 匹配几个字符之一

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name;
```

示例输出：

```shell
+-------------+
| prod_name   |
+-------------+
| 1 ton anvil |
| 2 ton anvil |
+-------------+
```

* 匹配特殊字符

MySQL的转义使用`\\`两个反斜杠。MySQL自己解析一个，正则表达式解析另一个。

| 空白元字符 | 说明     |
| ---------- | -------- |
| \\\f       | 换页     |
| \\\n       | 换行     |
| \\\r       | 回车     |
| \\\t       | 制表符   |
| \\\v       | 纵向制表 |

说明：每个元字符前面**只有两个反斜杠**，此处为了抵消掉markdown的语法，写了三个。

| 重复元字符 | 说明                          |
| ---------- | ----------------------------- |
| *          | 0个或多个匹配                 |
| +          | 1个或多个匹配（ 等于{1,} ）   |
| ?          | 0个或1个匹配 （ 等于{0,,1} ） |
| {n}        | 指定数目的匹配                |
| {n,}       | 不少于指定数目的匹配          |
| {n,m}      | 匹配数目的范围（m不超过255）  |

* 预定义字符集，字符类

| 字符类     | 说明                                                 |
| ---------- | ---------------------------------------------------- |
| [:alnum:]  | 任意字母和数字(同[a-ZA-Z0-9])                        |
| [:alpha:]  | 任意字符([a-zA-Z])                                   |
| [:blank:]  | 空格和制表(同[\\\t])                                 |
| [:cntrl:]  | ASCII控制字符(ASCII0到31和127)                       |
| [:digit:]  | 任意数字(同[0-9])                                    |
| [:graph:]  | 与[:print:]相同，但不包括空格                        |
| [:lower:]  | 任意小写字母(同[a-z])                                |
| [:print:]  | 任意可打印字符                                       |
| [:punct:]  | 既不在[:alnum:]又不在[:cntrl:]中的任意字符           |
| [:space:]  | 包括空格在内的任意空白字符(同[\\\f\\\n\\\r\\\t\\\v]) |
| [:upper:]  | 任意大写字母(同[A-Z])                                |
| [:xdigit:] | 任意十六进制数字(同[a-fA-F0-9])                      |

说明：每个双反斜杠**只有两个反斜杠**，此处为了抵消掉markdown的语法，写了三个。

* 定位元字符

| 定位元字符 | 说明       |
| ---------- | ---------- |
| ^          | 文本的开始 |
| $          | 文本的结尾 |
| [[:<:]]    | 词的开始   |
| [[:>:]]    | 词的结尾   |

* 简单的正则表达式测试

可以在不使用数据库表的情况下使用`SELECT`来测试正则表达式。`REGEXP`检查总是返回0(没有匹配)或者1(匹配)。可以用带文字串的REFEXP来测试表达式，并试验它们。如：

```mysql
SELECT 'hello' REGEXP '[0-9]';
```

示例输出：

```shell
+------------------------+
| 'hello' REGEXP '[0-9]' |
+------------------------+
|                      0 |
+------------------------+
```



### 创建计算字段

* 拼接

拼接是指将值联结到一起构成单个值。在MySQL的`SELECT`语句中，可使用`Concat()`函数来拼接两个列。

```mysql
SELECT Concat(vend_name,' (',vend_country,')') FROM vendors ORDER BY vend_name;
```

示例输出:

```shell
+-----------------------------------------+
| Concat(vend_name,' (',vend_country,')') |
+-----------------------------------------+
| ACME (USA)                              |
| Anvils R Us (USA)                       |
| Furball Inc. (USA)                      |
| Jet Set (England)                       |
| Jouets Et Ours (France)                 |
| LT Supplies (USA)                       |
+-----------------------------------------+
```

* 格式调整

可以使用`Trim()`函数去掉串左右两边的空格。`LTrim()`去掉串左边的空格。`RTtim()`去掉串右边的空格。

```mysql
SELECT Concat(RTrim(vend_name),' (',RTrim(vend_country),')') FROM vendors ORDER BY vend_name;
```

* 使用别名(alias)

别名：一个字段或值的替换名。别名使用`AS`关键字赋予。

别名的常见用途：在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解 							   时扩充它等等。

```mysql
SELECT Concat(RTrim(vend_name),' (',RTrim(vend_country),')') AS vend_title FROM vendors
ORDER BY vend_name;	
```

示例输出：

```shell
+-------------------------+
| vend_title              |
+-------------------------+
| ACME (USA)              |
| Anvils R Us (USA)       |
| Furball Inc. (USA)      |
| Jet Set (England)       |
| Jouets Et Ours (France) |
| LT Supplies (USA)       |
+-------------------------+
```

注: 仔细观察拼接段落的示例，很容易就可以看出两者的区别。

* 执行算术计算

计算字段的另一常见用途是对检索出的数据进行算术计算。

测试计算：`SELECT`可以省略`FROM`子句以便简单地访问和处理表达式。如`SELECT 3*2;` `SELECT Now();`。

```mysql
SELECT prod_id,quantity,item_price FROM orderitems WHERE order_num = 20005;
SELECT prod_id,quantity,item_price,
	   quantity*item_price AS expanded_price
FROM orderitems WHERE order_num = 20005;
```

示例输出:

```shell
+---------+----------+------------+
| prod_id | quantity | item_price |
+---------+----------+------------+
| ANV01   |       10 |       5.99 |
| ANV02   |        3 |       9.99 |
| TNT2    |        5 |      10.00 |
| FB      |        1 |      10.00 |
+---------+----------+------------+
==============================================================
+---------+----------+------------+----------------+
| prod_id | quantity | item_price | expanded_price |
+---------+----------+------------+----------------+
| ANV01   |       10 |       5.99 |          59.90 |
| ANV02   |        3 |       9.99 |          29.97 |
| TNT2    |        5 |      10.00 |          50.00 |
| FB      |        1 |      10.00 |          10.00 |
+---------+----------+------------+----------------+
```



### 使用数据处理函数

SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。

**函数没有SQL的可移植性强，如果决定使用函数，应该保证做好代码注释**

**大多数SQL实现支持以下类型的函数：**

1. 用于处理文本串的文本函数
2. 用于在数值数据上进行算术操作的数值函数
3. 用于处理日期和时间值并从这些值中提取特定成分的日期和时间函数
4. 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。



* 文本处理函数

常用的文本处理函数如下：

| 函数        | 说明              |
| ----------- | ----------------- |
| Left()      | 返回串左边的字符  |
| Length()    | 返回串的长度      |
| Locate()    | 找出串的一个子串  |
| Lower()     | 将串转换为小写    |
| LTrim()     | 去掉串左边的空格  |
| Right()     | 返回串右边的字符  |
| RTrim()     | 去掉串右边的空格  |
| Soundex()   | 返回串的SOUNDEX值 |
| SubString() | 返回子串的字符    |
| Upper()     | 将串转换为大写    |



* 日期和时间处理函数

**用日期进行过滤需要注意一些别的问题和使用特殊的MySQL函数**

1. 无论什么时候指定一个日期，不管是插入或更新表值还是用WHERE字句进行过滤，日期格式必须为yyyy-mm=dd。这是首选的日期格式，因为它排除了多义性。

常用日期和时间处理函数如下：

| 函数          | 说明                             |
| ------------- | -------------------------------- |
| AddDate()     | 增加一个日期（天、周等）         |
| AddTime()     | 增加一个时间（时、分等）         |
| CurDate()     | 返回当前日期                     |
| CurTime()     | 返回当前时间                     |
| Date()        | 返回日期时间的日期部分           |
| DateDiff()    | 计算两个日期之差                 |
| Date_Add()    | 高度灵活的日期运算函数           |
| Date_Format() | 返回一个格式化的日期或时间串     |
| Day()         | 返回一个日期的天数部分           |
| DayOfWeek()   | 对于一个日期，返回对应的是星期几 |
| Hour()        | 返回一个时间的小时部分           |
| Minute()      | 返回一个时间的分钟部分           |
| Month()       | 返回一个时期的月份部分           |
| Now()         | 返回当前日期和时间               |
| Second()      | 返回一个时间的秒部分             |
| Time()        | 返回一个日期时间的时间部分       |
| Year()        | 返回一个日期的年份部分           |



* 数值处理函数

常用数值处理函数如下：

| 函数   | 说明               |
| ------ | ------------------ |
| Abs()  | 返回一个数的绝对值 |
| Cos()  | 返回一个角度的余弦 |
| Exp()  | 返回一个数的指数值 |
| Mod()  | 返回除操作的余数   |
| Pi()   | 返回圆周率         |
| Rand() | 返回一个随机数     |
| Sin()  | 返回一个角度的正弦 |
| Sqrt() | 返回一个数的平方根 |



### 汇总数据

* 聚集 函数

我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。这些函数就是**聚集函数**。

**聚集函数：**运行在行组上，计算和返回单个值的函数。

**标准偏差聚集函数**



SQL聚集函数表：

| 函数    | 说明             |
| ------- | ---------------- |
| AVG()   | 返回某列的平均值 |
| COUNT() | 返回某列的行数   |
| MAX()   | 返回某列的最大值 |
| MIN()   | 返回某列的最小值 |
| SUM()   | 返回某列值之和   |

补充说明：

AVG()：只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使			 用多个AVG()函数。

​			 AVG()函数忽略列值为`NULL`的行。

COUNT(): 如果指定列名，则指定列值为`NULL`的行被COUNT()函数忽略，但如果COUNT()函数中用的是星号(*),则				 不忽略。

MAX()：忽略列值为`NULL`的行。

MIN()：忽略列值为`NULL`的行。	

SUM()：忽略列值为`NULL`的行。



* 聚集不同值

1. **不允许使用COUNT( DISTINCT )**

以上5个聚集函数都可以如下使用：

1. 对所有的行执行计算，指定`ALL`参数或不给参数(默认为`ALL`)。

2. 只包含不同的值，指定`DISTINCT`参数。

 ```mysql
SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id = 1003;
SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id = 1003;
 ```

示例输出：

```shell
+-----------+
| avg_price |
+-----------+
| 13.212857 |
+-----------+
================================================
+-----------+
| avg_price |
+-----------+
| 15.998000 |
+-----------+
```

* 组合聚集函数

`SELECT`语句可根据需要包含多个聚集函数。

```mysql
SELECT COUNT(*) AS num_items,
	   MIN(prod_price) AS price_min,
	   MAX(prod_price) AS price_max,
	   AVG(prod_price) AS price_avg
FROM products;
```

示例输出：

```shell
+-----------+-----------+-----------+-----------+
| num_items | price_min | price_max | price_avg |
+-----------+-----------+-----------+-----------+
|        14 |      2.50 |     55.00 | 16.133571 |
+-----------+-----------+-----------+-----------+
```

  

### 分组数据

* 数据分组

**分组**允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。分组是在`SELECT`语句的`GROUP BY`子句中建立的。

```mysql
SELECT vend_id,COUNT(*) AS num_prods 
FROM products 
GROUP BY vend_id;
```

示例输出：

```shell
+---------+-----------+
| vend_id | num_prods |
+---------+-----------+
|    1001 |         3 |
|    1002 |         2 |
|    1003 |         7 |
|    1005 |         2 |
+---------+-----------+
```

说明：上述的`SELECT`语句指定了两个列，vend_id包含产品供应商的ID,num_prods为计算字段(用COUNT(*)函数建立)。`GROUP BY`子句指示MySQL按照vend_id排序并分组数据。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。

**`GROUP BY`字句的重要规定**:















 

























































